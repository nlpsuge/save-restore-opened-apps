#!/usr/bin/env bash

MSG_SAVE="save running apps"
MSG_RESTORE="restore the previous running apps"
MSG_CLOSE_ALL_WINDOWS="close all windows"

LOCATION_OF_CURRENT_RUNNING_APPS=~/.current_running_apps

file_exists()
{
    if [ -e "$1" ]; then
        return 0
    else
        return 1
    fi
}

backup_or_create()
{
    file_exists "$LOCATION_OF_CURRENT_RUNNING_APPS"
    if [ $? == 0 ]; then
        # backup the old file
        cp "$LOCATION_OF_CURRENT_RUNNING_APPS" "$LOCATION_OF_CURRENT_RUNNING_APPS".old
    else
        # Also create none existing directories if necessary
        mkdir -p $(dirname "$LOCATION_OF_CURRENT_RUNNING_APPS")
        touch "$LOCATION_OF_CURRENT_RUNNING_APPS"    
    fi
}

save()
{
    backup_or_create

    p_l=$(wmctrl -lp | awk  '{ print $3 }' | sort | uniq)
    for p in $p_l; do
	# query process infomation
        ps -q $p -eo args --no-headers |
		# Append 'wine' if the command starts with 'SomeLetter:', eg 'C:', assume it is a wine-based application
		awk '{if ($0 ~ /^\w:/) {print "wine \"" $0 "\""} else {print $0};}';
    done > "$LOCATION_OF_CURRENT_RUNNING_APPS"
}

restore()
{
    SAVEIFS=$IFS
    IFS=$(echo -en "\n\b")
    for command in $(cat "$LOCATION_OF_CURRENT_RUNNING_APPS"); do
	bash -c "nohup  $command >/dev/null 2>&1 &"
    done
    IFS=$SAVEIFS
   
}

list()
{
    echo -n "Location: "
    ls "$LOCATION_OF_CURRENT_RUNNING_APPS"
    echo 
    cat "$LOCATION_OF_CURRENT_RUNNING_APPS"
}

confirm()
{
    echo -n "Do you really want to "$1"? [y/N]:"
    read c
    if [ x"$c" = x"N" ]; then
        exit 0
    elif [ x"$c" = x"y" ]; then
	# continue
	return 0
    else
	confirm "$1"
    fi
}

# Do not allow execute this tool using root
check_user()
{
    if [ $EUID -eq 0 ]; then
        echo "This tool must be run as a normal user"
	exit 1
    fi
}

pop_a_dialog_to_ask_for_restoring()
{
    zenity --timeout 5 --question --no-wrap --text="Do you want to restore the previous working state?"
    # Restore apps only after the 'ok' button is pressed or timeout
    [ $? == 0 -o $? == 5 ] &&  restore
}

get_all_windows_id()
{
    echo "$(wmctrl -l | awk  '{ print $1 }')"
}

close_all_windows()
{
    SAVEIFS=$IFS
    IFS=$'\n'
    
    window_ids="$(get_all_windows_id)"
    echo "Opening Windows: "$window_ids""
    for window_id in $window_ids; do
        echo "Closing "$window_id"($(wmctrl -lp | grep "$window_id"))"
        # Avoid race condition?
        sleep 0.25
        wmctrl -ic "$window_id"
    done

    IFS=$SAVEIFS

    verify_all_windows_closed
}

verify_all_windows_closed()
{
    echo Verifying...
    if [ "$(get_all_windows_id)" != "" ]; then
        sleep 0.5
        if [ "$(get_all_windows_id)" == "" ]; then
            exit 0
        fi
        echo Retrying...
        close_all_windows
    fi
}

check_user

if [ x"$1" = x"-s" -o x"$1" = x"--save" ]; then
    confirm "$MSG_SAVE"
    save
elif [ x"$1" = x"-r" -o x"$1" = x"--restore" ]; then
    confirm "$MSG_RESTORE"
    restore
elif [ x"$1" = x"-d" ]; then
    pop_a_dialog_to_ask_for_restoring
elif [ x"$1" = x"-C" -o x"$1" = x"--close-all" ]; then
    confirm "$MSG_CLOSE_ALL_WINDOWS"
    close_all_windows
elif [ x"$1" = x"-l" -o x"$1" = x"--list" ]; then
    list
else
    echo "-s/--save or -r/--restore or -l/--list or -d or -C/--close-all"
fi
